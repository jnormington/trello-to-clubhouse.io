package main

import (
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"path/filepath"

	ch "github.com/jnormington/clubhouse-go"
	trello "github.com/jnormington/go-trello"
)

const csvFile = "userMappingTtoC.csv"

// UserMap contains the users from Trello and Clubhouse
// with a Mapping which consumed and generated by the csv input.
type UserMap struct {
	TrelloMembers  *[]trello.Member
	ClubhouseUsers *[]ch.User
	BackupUserID   string

	GenerateCSV bool
	Mapping     map[string]string
}

// NewUserMap initializes a UserMap struct with trello and clubhouse members
func NewUserMap(to *TrelloOptions, co *ClubhouseOptions) *UserMap {
	var um UserMap

	um.TrelloMembers = to.ListMembers()
	um.ClubhouseUsers = co.ListUsers()
	um.BackupUserID = co.ImportUser.ID
	um.Mapping = make(map[string]string)

	return &um
}

// SetupUserMapping calls all the internal prompt functions
func (um *UserMap) SetupUserMapping() {
	um.promptShouldGenerateCSV()

	if um.GenerateCSV {
		um.buildUserMapToFile()
		fmt.Printf("*********************\n CSV generated: %s\n*********************\n", getCSVPath())
	}

	um.promptReadyToReadCSV()
	um.buildUserMapFromCSV()
}

func (um *UserMap) promptReadyToReadCSV() {

	fmt.Println("Is your CSV user mapping correct ?")
	fmt.Printf("CSV file: %s\n", getCSVPath())
	fmt.Printf("Are you ready to continue ?\n[1] Yes\n")

	i := promptUserSelectResource()

	if i != 1 {
		// If not 1 then call itself again
		um.promptReadyToReadCSV()
	}
}

func (um *UserMap) promptShouldGenerateCSV() {
	fmt.Println("To correctly map ticket owners to Clubhouse we need a user mapping CSV.")
	fmt.Println("If this is the first time running this program you need to generate one.")
	fmt.Println("We generate a csv of a best guess user mapping which you can edit to be correct")

	fmt.Println("If you already have one that is correct please select option 1")

	fmt.Println("Please select your option based on the above information:")

	for i, b := range yesNoOpts {
		fmt.Printf("[%d] %s\n", i, b)
	}

	i := promptUserSelectResource()
	if i >= len(yesNoOpts) {
		log.Fatal(errOutOfRange)
	}

	if i == 0 {
		um.GenerateCSV = true
	}
}

func (um UserMap) buildUserMapToFile() {
	var users = [][]string{{"TrelloUser", "ClubhouseEmail"}}

	// Try best guess mapping for csv output
	// to make it easier for larger teams
	for _, m := range *um.TrelloMembers {
		for _, u := range *um.ClubhouseUsers {
			if len(u.Permissions) == 0 {
				// User has no email address
				users = append(users, []string{m.Username, ""})
				continue
			}

			if m.FullName == u.Name {
				email := u.Permissions[0].EmailAddress
				users = append(users, []string{m.Username, email})
				continue
			}
		}
	}

	um.writeUserMapCSV(users)
}

func (um UserMap) writeUserMapCSV(users [][]string) {
	f, err := os.Create(getCSVPath())

	if err != nil {
		log.Fatalf("Error creating user mapping file: %s", err)
	}

	defer f.Close()

	w := csv.NewWriter(f)
	err = w.WriteAll(users)

	if err != nil {
		log.Fatalf("Error writing contents to file: %s", err)
	}
}

func (um *UserMap) buildUserMapFromCSV() {
	f, err := os.Open(getCSVPath())

	if err != nil {
		log.Fatalf("Error opening user mapping file: %s", err)
	}

	r := csv.NewReader(f)

	users, err := r.ReadAll()
	if err != nil {
		log.Fatalf("Error reading user mapping file: %s", err)
	}

	for i, u := range users {
		if i == 0 {
			// Its the header row
			continue
		}

		// If we dont have two items in the array
		// OR the username is blank ignore
		if len(u) != 2 || u[0] != "" {
			tm := um.getTrelloMemberID(u[0])
			cu := um.getClubhouseUserID(u[1])
			um.Mapping[tm] = cu
		}
	}
}

func (um UserMap) getClubhouseUserID(email string) string {
	for _, u := range *um.ClubhouseUsers {
		if len(u.Permissions) == 0 {
			continue
		}

		if u.Permissions[0].EmailAddress == email {
			return u.ID
		}
	}

	// If we get here no match found fallback to import user
	return um.BackupUserID
}

func (um UserMap) getTrelloMemberID(username string) string {
	for _, m := range *um.TrelloMembers {
		if m.Username == username {
			return m.Id
		}
	}

	// If we get here no match found fallback to import user
	return um.BackupUserID
}

func getCSVPath() string {
	p, err := os.Getwd()

	if err != nil {
		log.Fatalf("Failed to get current directory: %s", err)
	}

	return filepath.Join(p, csvFile)
}

// GetCreator returns the item from the user mapping
// or returns the backup user id
func (um UserMap) GetCreator(id string) string {
	u := um.Mapping[id]

	if u == "" {
		return um.BackupUserID
	}

	return u
}

func (um UserMap) GetCreatorOrString(id string) string {
	u := um.Mapping[id]
	return u
}
